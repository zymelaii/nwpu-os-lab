<div align='center'>
    <font size='6'>实验一 操作系统引导</font>
</div>

<div align='center'>
    <font size='4'>谷建华</font>
</div>
<div align='center'>
    <font size='4'>2023-09-20 v0.5</font>
</div>
#### 实验目的

1. 学习创建qemu虚拟机
2. 学习使用gdb调试qemu虚拟机
3. 学习使用make工程构建和管理工具
4. 学习启动引导原理和过程

#### 实验预习内容

1. 完成实验开发工具的安装
2. 了解gdb的基本功能、Make的基本用途
3. 了解操作系统引导的基本过程

#### 实验内容以及步骤

1. 制作硬盘启动盘在qemu虚拟机上加载启动.
   (1) 编译boot程序 ,生成二进制文件.
   (2) 创建虚拟机并挂载二进制文件作为硬盘 ,查看并记录运行结果.
2. 制作一个能够在虚拟机终端中显示`This is {学生自己的名字的拼音}’s boot`的启动引导盘.
   (1) 修改boot程序 ,重新编译.
   (2) 制作硬盘启动盘,在虚拟机上加载启动,查看并记录结果.
3. 结合实验参考中的int 10h相关文档 ,依次实现下面功能：
   (1) 清除屏幕上所有字符.
   (2) 然后在第19行第38处显示蓝底白色字符串“NWPU”.
   (3) 最后让光标置于10行10列处.
   (4) 制作硬盘启动盘 ,在虚拟机上加载启动,查看并记录结果.
4. 查出`err_boot.asm`启动引导程序的问题
   (1) 制作硬盘启动盘,在虚拟机上加载启动,查看并记录结果.
   (2) 发现代码存在的问题 ,并改正之.
5. 编写makefile文件,要求实现以下功能：
   (1) 输入命令`make`能够实现从`boot.asm`编译成`boot.bin`.
   (2) 根据`boot.asm`和`boot.bin`的创建时间先后分别做两次实验`make`,观察`make`执行情况并记录.
   (3) 输入命令`make clean`实现`boot.bin`的删除.
   (4) 输入命令`make run`实现虚拟机的快速创建.
6. 可以做但是不作任何要求的内容(完全没有任何影响):
   - 修改qemu虚拟机的启动项,让虚拟机从USB上启动（通过虚拟机的BIOS设置实现）.  
     （1）修改boot的显示：boot from USB.  
     （2）编译boot程序,并作成USB启动盘,在虚拟机上加载启动,查看并记录结果.
       注意：USB可能需要格式化成FAT12或FAT16格式.
   - 真机从USB启动  
     （1）在一个真实的USB盘上制作成一个启动盘.  
     （2）把一台物理机设置为从USB盘启动（通过修改BIOS设置实现）,在物理机上插上USB盘,加电启动该物理机,查看并记录结果.

#### 实验总结

1. 试说明从计算机加电后,到引导程序的第一条指令被运行的过程.
2. boot程序中,在显示器上显示字符串的功能是如何完成的？
3. 结合gdb调试信息 ,给出进入BIOS中第一条指令的地址 ,触发int 10h中断后第一条指令的地址？

#### 实验参考

##### 启动引导

在x86类型的计算机启动的时候（摁下电源开关）,系统会首先运行固件程序（firmware）,固件程序由硬件厂商已经硬编码好的,在此次实验环境下是bios程序,bios会按某种顺序遍历所有可能的硬件存储设备（软驱/硬盘/光盘）寻找启动引导设备.

启动引导设备需要满足的要求是它的第0个扇区（一般是0柱面、0磁道、0扇区,一个扇区有512字节）的最后两个字节数据为`0xaa55`（硬件厂商规定）.如果bios发现一个设备满足启动引导设备要求,则会将该设备的第0个扇区加载到内存中的`0:0x7c00`处,最后将pc跳至`0:0x7c00`,将执行流交给引导程序.也就是说,广义上讲,我们的操作系统的第一条指令就是在`0:0x7c00`.

##### 创建boot镜像

此次实验通过qemu虚拟机完成,虚拟机可以简单理解为模拟真实硬件环境的软件,在使用虚拟模拟硬件环境之前,我们需要先准备一个启动引导（以下称为boot）设备.

准备boot设备需要先编写一个boot程序,文件夹下的`boot.asm`存储的是启动引导的汇编源代码,通过下列命令可以将它编译成二进制文件:

```shell
nasm boot.asm -o boot.bin
```

在编译完后`boot.bin`就是大小为一个扇区（512B）的boot程序,可以通过以下命令验证：

```shell
file ./boot.bin #验证文件类型
stat ./boot.bin #验证文件大小
```

##### 创建qemu虚拟机

在写完boot程序后,这个程序本身就可以作为一个镜像文件挂在到虚拟机上,通过以下命令可以运行虚拟机并把boot.bin挂载到硬盘上：

```shell
qemu-system-i386                \ #运行的虚拟机环境为i386
-boot order=c                   \ #运行的时候首先检查硬盘有没有启动引导程序
-drive file=boot.bin,format=raw   #抽象boot.bin成为一个硬盘设备,模拟挂在到虚拟环境中

#源命令,可复制,\允许一个命令分多行输入
qemu-system-i386                \
-boot order=c                   \
-drive file=boot.bin,format=raw
```

输入命令就能看到图形化的界面弹出,并按照预期打印一个字符串.

> 在试点班中, 我们默认使用qemu虚拟机来完成实验, 如果你想要研究另一种虚拟机bochs, 可以在群文件中找`miniOS实验手册**.docx`来看看多年前的试点班是怎么做的, 比较一下两种虚拟机都有什么优势和缺点.

##### 在qemu虚拟机里使用gdb

为了能够让启动过程细化,我们还支持了对虚拟机的gdb调试,命令如下：

```shell
#-S 让指令停在bios程序的第一条指令,为了能够让gdb操作
#-s 让虚拟机开放1234端口供gdb调试（数据通过本地回环网络tcp传输）
qemu-system-i386                \
-boot order=c                   \
-drive file=boot.bin,format=raw \
-S -s

#-ex 在进入gdb的时候自动填入命令,减少手工输入的时间
#set tdesc filename target.xml 
#由于boot程序运行环境为16位,默认情况下gdb不能支持16位指令的解析,需要导入xml文件让解析正常
#xml文件在同文件夹下
#target remote localhost:1234
#让gdb连接1234端口用于开始调试
gdb                                 \
-ex 'set tdesc filename target.xml' \
-ex 'target remote localhost:1234'
```

开启两个终端,一个用于开启虚拟机,另一个用于开启gdb,就能通过gdb调试虚拟机.

这里简单介绍一下gdb可能会用到的相关命令

```shell
si #执行下条汇编指令
b *0x7c00 #在地址7c00处打断点
c #继续执行程序直到遇到一个断点
p $pc #打印当前的pc
disp $ah #打印ah寄存器,每次指令流发生变化的时候都会再打印一遍
info registers #打印所有寄存器值
q #退出调试,不过虚拟机端仍需手动退出
#上面基础命令讲完了,接下来是比较好用的命令
disass 0x7c00,0x7e00 #对[0x7c00,0x7e00)的所有数据进行反汇编（刚好是boot程序）
x /10i $pc #将pc之后的10条命令打印出来
x /16x 0x7c00 #将0x7c00后的16个字节的数据按照16进行打印
disp /10i $pc #将pc之后的10条命令打印出来,每次执行流发生变化重复打印一遍
layout asm #显示汇编
layout regs #显示寄存器
```

> 关于xml文件的解释: i386-32bit.xml具体指定了目标架构中的寄存器信息供gdb解析使用, target.xml引用i386-32bit.xml文件并描述目标架构(也就是这里的16位i8086). 如果你对这个内容感兴趣,请参考GDB文档中的Target Description Format一节, 同时这个[链接](https://astralvx.com/debugging-16-bit-in-qemu-with-gdb-on-windows/)可能会对实验有所帮助.

##### int 10h中断

int 10h 中断是一个实模式显示服务,预实验中会可能用到的功能

+ ah=0x02,用于改变光标位置
    bh=页号
    dh=行号
    dl=列号
+ ah=0x06,用于将一个矩形区域内的内容整体向上移动,矩形底端用空字符填充
    al=行数（如果为0,表示使矩形区域的所有列均向上移,即清空）
    bh=填充空行时用的背景色和前景色
    ch=矩形左上角行号
    cl=矩形左上角列号
    dh=矩形右下角行号
    dl=矩形右下角列号
+ ah=0x13,用于输出一个字符串
    al=光标属性（简化成0即可）
    bh=页号
    bl=高两位颜色码为颜色底,低两位颜色码为字符颜色
    cx=串长度
    dh=字符串首字符起始行
    dl=字符串首字符起始列
    es:bp=字符串地址
+ 颜色码

颜色码 | 颜色 | 颜色码 | 颜色
------|-----|--------|----
0000|黑色|1000 |灰色 
0001|蓝色|1001|淡蓝色
0010|绿色|1010|淡绿色
0011|青色|1000|淡青色
0100|红色|1100|淡红色
0101|紫红色|1101|淡紫红色
0110|棕色|1110|黄色
0111|银色|1111|白色

BIOS中断表可以参考http://www.ctyme.com/intr/int.htm